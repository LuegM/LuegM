[{"content":"Using Obsidian in conjunction with GitHub offers a powerful solution for teams to create, manage, and maintain their documentation collaboratively. This post guides you through setting up an Obsidian vault with a GitHub repository to enable seamless documentation workflow for your team.\nSetting Up Your GitHub Repository Create a New GitHub Repository: Start by creating a new repository on GitHub. Include an `.md` (Markdown) file to serve as the starting point of your documentation. Generate a Personal Access Token: Follow GitHub\u0026rsquo;s guide to create a personal access token. This token will allow you to clone and push changes to your repository securely. Install Git: Ensure Git is installed on your machine. This is necessary for cloning the repository and managing versions of your documentation.\nClone the Repository: Use your personal access token to clone the repository to your local machine. Replace \u0026lt;PERSONAL_ACCESS_TOKEN\u0026gt;, \u0026lt;USERNAME\u0026gt;, and \u0026lt;REPO\u0026gt; with your information:\nhttps://\u0026lt;PERSONAL_ACCESS_TOKEN\u0026gt;@github.com/\u0026lt;USERNAME\u0026gt;/\u0026lt;REPO\u0026gt;.git Integrating Obsidian Install Obsidian: If you haven\u0026rsquo;t already, you can download and install Obsidian from the official website or use Homebrew, a package manager for macOS, to install it. To install Obsidian using Homebrew, open your terminal and run the following command:\nbrew install --cask obsidian After installation, open the cloned repository folder as your vault.\nInstall the Git Community Plugin: Inside Obsidian, navigate to the community plugins section and install the Git plugin. This plugin will enable you to commit and push changes directly from Obsidian.\nEnhancing Your Workflow To ensure a smooth workflow and keep your vault clean, consider the following enhancements:\nExclude Unnecessary Files: Create a `.gitignore` file in your vault\u0026rsquo;s root directory. Add configurations to exclude cache files, system-specific files, and Obsidian\u0026rsquo;s settings that you don\u0026rsquo;t want to track. For example:\n# to exclude Obsidian\u0026#39;s settings (including plugin and hotkey configurations) .obsidian/ # Add below lines to exclude OS settings and caches .trash/ .DS_Store Automatic Backups: Enable automatic backups to periodically save your work without manual intervention. You can set up the plugin to commit changes at specified intervals, ensuring your documentation is always up-to-date.\nPull Changes on Startup: Enable the \u0026ldquo;Pull updates on startup\u0026rdquo; option in the Git plugin\u0026rsquo;s settings to configure the plugin to pull changes from the remote repository each time you start Obsidian. This setting, found under the \u0026ldquo;Backup\u0026rdquo; section, ensures that your local vault is always synchronized with the latest changes made by your team.\nHotkeys for Common Git Actions: Assign hotkeys to frequent Git operations like commit, push, and pull. This streamlines your workflow by allowing you to quickly perform version control tasks without leaving Obsidian.\nSource Control and History Views Using the Source Control View: Access the Source Control View by using the command palette (Ctrl+P or Cmd+P) and searching for \u0026ldquo;Open Source Control View\u0026rdquo;. This view lets you stage changes, commit them, and push to your remote repository, all from within Obsidian.\nUsing the History View: Access the History View by using the command palette (Ctrl+P or Cmd+P) and searching for \u0026ldquo;Open History View\u0026rdquo;. The History View displays a list of commits with their messages, authors, and timestamps. Clicking on a commit shows the changes made, offering insights into the documentation\u0026rsquo;s evolution.\nConfiguring these features enhances your documentation process, making it more efficient and collaborative. It also helps in maintaining a detailed history of changes, which is invaluable for tracking progress and resolving any issues that may arise.\nCollaborative Documentation Best Practices Commit Messages: Encourage clear and concise commit messages that accurately describe the changes made. Documentation Structure: Organize your documentation in a way that\u0026rsquo;s easy for all team members to navigate and contribute to. Regular Pulls: To avoid conflicts, pull changes frequently, especially before starting a new editing session. Conclusion By integrating Obsidian with GitHub, teams can leverage the flexibility and power of markdown-based documentation with the version control and collaboration features of GitHub. This setup not only enhances the documentation process but also fosters a collaborative environment for team members to contribute their knowledge and expertise.\nFor a deeper dive into the Git plugin\u0026rsquo;s features and setup, especially for mobile users and advanced configurations, check out the official documentation or the Github page.\nRemember, effective documentation is a continuous effort that requires the collaboration and contributions of all team members. Happy documenting!\n","permalink":"http://localhost:1313/posts/obsidiangit/","summary":"Using Obsidian in conjunction with GitHub offers a powerful solution for teams to create, manage, and maintain their documentation collaboratively. This post guides you through setting up an Obsidian vault with a GitHub repository to enable seamless documentation workflow for your team.\nSetting Up Your GitHub Repository Create a New GitHub Repository: Start by creating a new repository on GitHub. Include an `.md` (Markdown) file to serve as the starting point of your documentation.","title":"Leveraging Obsidian with GitHub for Collaborative Documentation"},{"content":"Integrating a WiFi setup with a captive portal into your ESP32 projects significantly enhances the user experience by simplifying the network connection process. This tutorial will guide you through setting up your ESP32 project with a captive portal using PlatformIO in Visual Studio Code (VSCode) and incorporating the WiFiManager library.\nSetting up PlatformIO in VSCode PlatformIO is an open-source ecosystem for IoT development. It supports a vast number of boards and frameworks, including ESP32. To integrate PlatformIO with VSCode:\nInstall VSCode: Download and install Visual Studio Code from its official website. Install the PlatformIO Extension: Open VSCode, go to the Extensions view by clicking on the square icon on the sidebar, or pressing Ctrl+Shift+X. Search for \u0026ldquo;PlatformIO IDE\u0026rdquo; and install it. Restart VSCode: Once installed, restart VSCode to complete the setup. Initializing Your Project with PlatformIO After setting up PlatformIO, create a new project:\nOpen PlatformIO Home by clicking on the PlatformIO icon in the sidebar. Click on “New Project”. Enter a name for your project, select \u0026ldquo;Espressif ESP32 Dev Module\u0026rdquo; as the board, and choose your preferred framework (e.g., Arduino). Click \u0026ldquo;Finish\u0026rdquo; to create the project. Adding WiFiManager Dependency With your project set up, you need to include the WiFiManager library, which facilitates the WiFi connection and captive portal functionality. To do this, add the following line to your platformio.ini file:\nlib_deps = https://github.com/tzapu/WiFiManager.git This line tells PlatformIO to download and include the WiFiManager library from the specified GitHub repository in your project.\nImplementing WiFi Setup with Captive Portal The WiFiManager library simplifies the WiFi connection process by automatically connecting to known networks or launching a captive portal when the device can\u0026rsquo;t connect to any known network. Below is an example code snippet on how to implement this:\n#include \u0026lt;WiFiManager.h\u0026gt; void setup() { Serial.begin(9600); // Initializes WiFiManager WiFiManager wifiManager; // Tries to connect to the last known network. // Launches a captive portal if the connection fails or the timeout is reached. if(!wifiManager.autoConnect(\u0026#34;ESP32_AP\u0026#34;)) { Serial.println(\u0026#34;Failed to connect to WiFi. Please restart.\u0026#34;); ESP.restart(); } // If you reach this point, you have successfully connected to a network. Serial.println(\u0026#34;Connected to WiFi!\u0026#34;); } void loop() { // Your repeated code goes here. } This code automatically attempts to connect the ESP32 to a previously connected WiFi network. If it fails or no known network is available, it launches a captive portal named \u0026ldquo;ESP32_AP.\u0026rdquo; The user can connect to this network and select a WiFi network for the ESP32 to connect to.\nConfiguration Options In addition to the basic setup, the WiFiManager library provides several options to customize the behavior of the captive portal and WiFi connection process to suit your project needs. Here are some of the configurable options:\nPortal timout\n// Sets the AP timeout to 120 seconds. The ESP restarts after 120 seconds without a connection. wifiManager.setConfigPortalTimeout(120); Only show some buttons\n// Remove all buttons except the wifi config and exit std::vector\u0026lt;const char *\u0026gt; wm_menu = {\u0026#34;wifi\u0026#34;, \u0026#34;exit\u0026#34;}; wifiManager.setMenu(wm_menu); Erase saved wifi credentials\n// Erasing the WiFi settings Serial.println(\u0026#34;Resetting\u0026#34;); wifiManager.resetSettings(); ESP.restart(); Final Steps and Testing After implementing the code, compile and upload it to your ESP32. To test the captive portal functionality, ensure the ESP32 isn\u0026rsquo;t connected to any known networks. It should broadcast an SSID named \u0026ldquo;ESP32_AP.\u0026rdquo; Connect to this network using a smartphone or computer, and a captive portal should appear, prompting you to select a WiFi network and enter the password for the ESP32 to connect to.\nBy following this guide, you\u0026rsquo;ve successfully integrated a WiFi setup with a captive portal into your ESP32 project, enhancing its accessibility and user-friendliness.\n","permalink":"http://localhost:1313/posts/captiveportal/","summary":"Integrating a WiFi setup with a captive portal into your ESP32 projects significantly enhances the user experience by simplifying the network connection process. This tutorial will guide you through setting up your ESP32 project with a captive portal using PlatformIO in Visual Studio Code (VSCode) and incorporating the WiFiManager library.\nSetting up PlatformIO in VSCode PlatformIO is an open-source ecosystem for IoT development. It supports a vast number of boards and frameworks, including ESP32.","title":"Integrating WiFi Setup with Captive Portal in your ESP32 Projects"},{"content":"Welcome to my step-by-step guide on how to build your own digital ticket for the Apple Wallet. Today, I\u0026rsquo;m going to show you how to set up a backend system and create an app with SwiftUI that lets you store and use tickets right on your iPhone.\nWe’re going to turn the Klimaticket, a yearly public transport ticket in Austria, into a ticket on your phone. This will make your travels simpler and help the planet too.\nBy the time you finish this guide, you\u0026rsquo;ll learn how to create digital passes for your wallet on your iPhone.\nPreparations Info\nGithub-Link: WalletPass\nCreate the server folder and initialize it mkdir server \u0026amp;\u0026amp; cd server \u0026amp;\u0026amp; npm init -y Next, we can add Fastify with npm i fastify We will use https://github.com/alexandercerutti/passkit-generator: add it to your server dependencies by running this command while in the ./server directory. npm i passkit-generator install openssl Mac (Homebrew)\nbrew install openssl Linux\nsudo apt install openssl create a cert folder (/server/cert) mkdir cert Create the Certificates Create a new pass type identifier (direct link) and provide it with a description and a reverse-domain identifier (starting with \u0026ldquo;pass.\u0026rdquo;). You will have to put this identifier as a value for passTypeIdentifier in the pass.json file or as a prop.\nConfirm and register the new identifier.\nIn the list of your passTypeIds (filter), click on your new pass id to edit it.\nClick on \u0026ldquo;Create Certificate\u0026rdquo;. To provide Apple with the required Certificate Signing Request, we\u0026rsquo;ll have first to generate a private key. This will be your signerKey. Having it as .key or .pem doesn\u0026rsquo;t make any difference: it is still a PEM.\n# If you want to set it as a passphrase, add \u0026#34;-passout pass:\u0026lt;your-passphrase\u0026gt;\u0026#34; before \u0026#34;2048\u0026#34;. # If you follow the passphrase way, you\u0026#39;ll have to set a \u0026#34;-passin pass:\u0026lt;your-passphrase\u0026gt;\u0026#34; (or insert it manually) # in the next commands and, once done, set it to passkit-generator at `signerKeyPassphrase`. $ openssl genrsa -out signerKey.key 2048 Generate a CSR using your private key. Usually, the final file should have a .csr extension, but there is no difference: .csr is an ASN.1 Base64 encoded text. Therefore it can have any extension you want. You\u0026rsquo;ll be prompted to insert a few pieces of information one per prompt. Continue reading. $ openssl req -new -key signerKey.key -out request.certSigningRequest In the required information, you\u0026rsquo;ll have to insert Apple CA\u0026rsquo;s information, like below (those among asterisks). If none, press Enter to skip. After the email address, you won\u0026rsquo;t need any further information. So press Enter until you won\u0026rsquo;t finish.\nCountry Name (2-letter code) [AU]: US State or Province Name [Some-State]: United States Locality Name []: Organization Name [Internet Widgits Pty Ltd]: Apple Inc. Organizational Unit Name []: Apple Worldwide Developer Relations Common Name []: Apple Worldwide Developer Relations Certification Authority Email Address []: your-email Take the generated file request.certSigningRequest and upload it to the provisioning portal at step 4. Once processed, you\u0026rsquo;ll be able to download a certificate like pass.cer\nOnce downloaded the certificate, you\u0026rsquo;ll have to convert it to .pem (from a DER-encoded to PEM Base64 encoded). Save the result somewhere safe. You\u0026rsquo;ll be using it in your application as signerCert.\n# .cer to .pem $ openssl x509 -inform DER -outform PEM -in signerCert.cer -out signerCert.pem Go to this website: Apple PKI and download the certificate called Worldwide Developer Relations - G4 Take the WWDR Certificate and convert it to a .pem base64. # .cer to .pem $ openssl x509 -inform DER -outform PEM -in \u0026lt;cert name\u0026gt;.cer -out wwdr.pem Copy the 3 certificates to the folder /server/cert signerCert.pem signerKey.key wwdr.pem And you are done with the certificates. 🎉 Now get back and try to create your first pass!\nCreate a model You can either create a said model manually by following the official guidelines from Apple or just use a visual tool like Passkit Visual Designer provided by the authors of the Passkit Generator.\nOr use the file I provide in my Github-Repo: Transit.pass\nPut the Model-Pass in the server folder like this: /server/\u0026lt;modelName\u0026gt;.pass/\nIn my case: /server/transit.pass/\nWarning\nPlease keep in mind that even if you are using the example model folder from the repository, you need to edit pass.json to replace passTypeIdentifier and teamIdentifier with your own values matching those from your signing certificate. If you don’t do this then you won’t be able to sign the passes properly.\nSetup the Server Finally, we are ready to generate our first Apple Wallet pass. Let’s open ./server/index.js and add a new POST endpoint looking like this:\nconst path = require(\u0026#39;path\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const crypto = require(\u0026#39;crypto\u0026#39;); const fastify = require(\u0026#39;fastify\u0026#39;)( { logger: true, bodyLimit: 15 * 1048576, } ); const { PKPass } = require(\u0026#39;passkit-generator\u0026#39;); // Certificates const certDirectory = path.resolve(process.cwd(), \u0026#39;cert\u0026#39;); const wwdr = fs.readFileSync(path.join(certDirectory, \u0026#39;wwdr.pem\u0026#39;)); const signerCert = fs.readFileSync(path.join(certDirectory, \u0026#39;signerCert.pem\u0026#39;)); const signerKey = fs.readFileSync(path.join(certDirectory, \u0026#39;signerKey.key\u0026#39;)); // Input Fields fastify.post(\u0026#39;/\u0026#39;, async (request, reply) =\u0026gt; { const { name, cardNr, dateFrom, dateTo, dateBirth, type } = request.body; const passID = crypto.createHash(\u0026#39;md5\u0026#39;).update(`${name}_${Date.now()}`).digest(\u0026#39;hex\u0026#39;) // Generate the pass const pass = await PKPass.from( { // Path to your pass model directory model: path.resolve(process.cwd(), \u0026#39;transit.pass\u0026#39;), certificates: { wwdr, signerCert, signerKey, }, }, { serialNumber: passID, }, ); // Expiration Format const [day, month, year] = dateTo.split(\u0026#39;.\u0026#39;); const date = new Date(`${year}-${month}-${day}T23:59:00+01:00`); // Expiration Date pass.setExpirationDate(date); // headerFields pass.headerFields.push( { key: \u0026#39;type\u0026#39;, value: type } ); // primaryFields pass.primaryFields.push( { key: \u0026#39;name\u0026#39;, value: name } ); // secondaryFields pass.secondaryFields.push( { key: \u0026#39;cardNr\u0026#39;, label: \u0026#34;Kartennummer\u0026#34;, value: cardNr }, { key: \u0026#39;dateTo\u0026#39;, label: \u0026#34;Ablaufdatum\u0026#34;, value: dateTo }, ); // auxiliaryFields pass.auxiliaryFields.push( { key: \u0026#39;dateBirth\u0026#39;, label: \u0026#34;Geburtsdatum\u0026#34;, value: dateBirth }, { key: \u0026#39;dateFrom\u0026#39;, label: \u0026#34;Beginn\u0026#34;, value: dateFrom } ); reply.header(\u0026#39;Content-Type\u0026#39;, \u0026#39;application/vnd-apple.pkpass\u0026#39;); reply.send(pass.getAsBuffer()); }); // Start the server fastify.listen({ port: process.env.PORT ?? 3000, host: \u0026#39;0.0.0.0\u0026#39; }, function (err) { if (err) { fastify.log.error(err); process.exit(1); } fastify.log.info(`Server listening on ${fastify.server.address().port}`); }); Let’s test it: from the ./server folder, run node index.js. You should get a confirmation that your server is running at http://localhost:3000.\nThe next step involves using Postman, curl, or any other tool that will let you make a POST request to http://localhost:3000.\nUse this as the request body:\n{ \u0026#34;name\u0026#34;: \u0026#34;John Smith\u0026#34; \u0026#34;cardNr\u0026#34;: \u0026#34;1234\u0026#34;, \u0026#34;dateFrom\u0026#34;: \u0026#34;01.01.2020\u0026#34;, \u0026#34;dateTo\u0026#34;: \u0026#34;12.12.2025\u0026#34;, \u0026#34;dateBirth\u0026#34;: \u0026#34;01.01.1999\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;Classic\u0026#34; } If all is done right, you should receive back a binary file that you can save under a name with a .pkpass extension, which will allow you to preview the pass with Pass Viewer built-in into MacOS.\nAdd an Image and use an Aztec Code Info\nYou can find the complete code here: Github: index.js\nChange this part of the code to include aztecCode and image\nfastify.post(\u0026#39;/\u0026#39;, async (request, reply) =\u0026gt; { const { name, cardNr, dateFrom, dateTo, dateBirth, aztecCode, type, image } = request.body; Also add this Code to add them to the pass.\n// MARK: add Infos to the pass // Barcode Type const barcode = { format: \u0026#34;PKBarcodeFormatAztec\u0026#34;, message: aztecCode, messageEncoding: \u0026#34;iso-8859-1\u0026#34; }; // Barcode Data pass.setBarcodes(barcode); // Add a Image to the pass // Decode the image from Base64 and save or use it directly const imageBuffer = Buffer.from(image, \u0026#34;base64\u0026#34;); // Now you can use the image in your PKPass pass.addBuffer(\u0026#34;thumbnail.png\u0026#34;, imageBuffer); pass.addBuffer(\u0026#34;thumbnail@2x.png\u0026#34;, imageBuffer); Create the App Create a Model to Pass Data class FormData: ObservableObject { @Published var fullName: String = \u0026#34;\u0026#34; @Published var cardNr: String = \u0026#34;\u0026#34; @Published var dateFrom: String = \u0026#34;\u0026#34; @Published var dateTo: String = \u0026#34;\u0026#34; @Published var dateBirth: String = \u0026#34;\u0026#34; @Published var type: String = \u0026#34;Classic\u0026#34; @Published var aztecCode: String = \u0026#34;\u0026#34; @Published var imgBase64: String = \u0026#34;\u0026#34; var isComplete: Bool { return !fullName.isEmpty \u0026amp;\u0026amp; !cardNr.isEmpty \u0026amp;\u0026amp; !dateFrom.isEmpty \u0026amp;\u0026amp; !dateTo.isEmpty \u0026amp;\u0026amp; !dateBirth.isEmpty \u0026amp;\u0026amp; !type.isEmpty \u0026amp;\u0026amp; !aztecCode.isEmpty \u0026amp;\u0026amp; !imgBase64.isEmpty } } Create the View for the user input The provided code snippet is for an iOS app\u0026rsquo;s user interface where you fill out a form with personal and card details to get a digital pass. Here\u0026rsquo;s how it works, in simple terms:\nYou enter your name, birthdate, card type, and card number. You can also pick dates for when the card starts and ends. The app has a \u0026ldquo;Scan Code\u0026rdquo; button. When you tap it, it uses the \u0026ldquo;CodeScanner\u0026rdquo; dependency to scan a code, like the barcode on your card. You can also add a picture by choosing one from your photos. Once all your info is complete, you tap \u0026ldquo;Fetch and Open Pass,\u0026rdquo; and the app sends your info to a server. Then it gets back a digital pass, which looks like a little card in your app\u0026rsquo;s wallet. If you tap the settings icon, you can change the server\u0026rsquo;s IP address. If something doesn\u0026rsquo;t work right, the app will show you an error message so you know what went wrong.\nimport SwiftUI import PhotosUI import PassKit import CodeScanner struct ContentView: View { @StateObject private var formData = FormData() @State private var isLoading: Bool = false @State private var pass: PKPass? @State private var showPassView: Bool = false @State private var showScanner: Bool = false @State private var showError: Bool = false @State private var showSetting = false @State private var errorText: String = \u0026#34;An error occurred while importing the pass.\u0026#34; @State private var serverIP = \u0026#34;services.it-lueg.at:3000\u0026#34; @State private var dateFrom: Date = Date() @State private var dateTo: Date = Date() @State private var dateBirth: Date = Date() private var dateFormatter: DateFormatter { let formatter = DateFormatter() formatter.dateFormat = \u0026#34;dd.MM.yyyy\u0026#34; return formatter } @State private var avatarItem: PhotosPickerItem? @State private var avatarImage: Image? var body: some View { NavigationStack { Form { Section { TextField(\u0026#34;Full Name\u0026#34;, text: $formData.fullName) DatePicker(\u0026#34;Birth Date\u0026#34;, selection: $dateBirth, displayedComponents: .date) .onChange(of: dateBirth) { newDate in formData.dateBirth = dateFormatter.string(from: newDate) } } header: { Text(\u0026#34;Personal Infos\u0026#34;) } Section { TextField(\u0026#34;Type\u0026#34;, text: $formData.type) TextField(\u0026#34;Card Number\u0026#34;, text: $formData.cardNr) DatePicker(\u0026#34;Valid From\u0026#34;, selection: $dateFrom, displayedComponents: .date) .onChange(of: dateFrom) { newDate in formData.dateFrom = dateFormatter.string(from: newDate) } DatePicker(\u0026#34;Valid Until\u0026#34;, selection: $dateTo, displayedComponents: .date) .onChange(of: dateTo) { newDate in formData.dateTo = dateFormatter.string(from: newDate) } } header: { Text(\u0026#34;Card Infos\u0026#34;) } Section { Button(action: { showScanner.toggle() }, label: { Label { HStack { Text(\u0026#34;Scan Code\u0026#34;) Spacer() if formData.aztecCode != \u0026#34;\u0026#34; { Image(systemName: \u0026#34;checkmark.circle.fill\u0026#34;) .foregroundStyle(.green) } } } icon: { Image(systemName: \u0026#34;qrcode\u0026#34;) } }) PhotosPicker(selection: $avatarItem, matching: .images, label: { Label { HStack { Text(\u0026#34;Picture\u0026#34;) Spacer() if formData.imgBase64 != \u0026#34;\u0026#34; { Image(systemName: \u0026#34;checkmark.circle.fill\u0026#34;) .foregroundStyle(.green) } } } icon: { Image(systemName: \u0026#34;face.smiling\u0026#34;) } }) } Section { Button(action: { postAndPreviewPass() }) { Label { HStack { Text(\u0026#34;Fetch and Open Pass\u0026#34;) Spacer() if isLoading { ProgressView() } } } icon: { Image(systemName: \u0026#34;wallet.pass.fill\u0026#34;) .foregroundStyle(formData.isComplete ? .blue : .gray.opacity(0.5)) } } .disabled(!formData.isComplete) } } .onChange(of: avatarItem) { _ in Task { if let data = try? await avatarItem?.loadTransferable(type: Data.self) { if let uiImage = UIImage(data: data) { // Determine the dimensions of the original image let originalSize = uiImage.size let minDimension = min(originalSize.width, originalSize.height) // Calculate the cropping rectangle let croppingRect = CGRect(x: (originalSize.width - minDimension) / 2, y: (originalSize.height - minDimension) / 2, width: minDimension, height: minDimension) // Crop the image to a square let croppedImage = uiImage.cropping(to: croppingRect) // Proceed with your existing code... let maxDimension: CGFloat = 300 // Set the maximum dimension you want let scaledImage = croppedImage!.scaledDown(to: maxDimension) // Create a new image context UIGraphicsBeginImageContextWithOptions(scaledImage.size, false, 0.0) defer { UIGraphicsEndImageContext() } // Create a path that is a circle let path = UIBezierPath(ovalIn: CGRect(origin: .zero, size: scaledImage.size)) path.addClip() // Draw the image in the current context scaledImage.draw(in: CGRect(origin: .zero, size: scaledImage.size)) // Get the clipped image let clippedImage = UIGraphicsGetImageFromCurrentImageContext() // Convert the clipped image to Data, then to Base64 formData.imgBase64 = clippedImage?.pngData()?.base64EncodedString() ?? \u0026#34;\u0026#34; print(formData.imgBase64) return } } print(\u0026#34;Failed\u0026#34;) } } .sheet(isPresented: $showPassView) { AddPassView(pass: $pass) } .sheet(isPresented: $showScanner) { CodeScannerView(codeTypes: [.aztec], showViewfinder: true, simulatedData: \u0026#34;Paul Hudson\u0026#34;) { response in switch response { case .success(let result): formData.aztecCode = result.string print(\u0026#34;Found code: \\(result.string)\u0026#34;) showScanner.toggle() case .failure(let error): print(error.localizedDescription) } } .ignoresSafeArea() .presentationDetents([.medium]) } .alert(isPresented: $showError) { Alert(title: Text(\u0026#34;Error\u0026#34;), message: Text(errorText), dismissButton: .default(Text(\u0026#34;OK\u0026#34;))) } .alert(\u0026#34;Server IP\u0026#34;, isPresented: $showSetting) { TextField(\u0026#34;Name\u0026#34;, text: $serverIP) } .navigationTitle(\u0026#34;KlimaWallet\u0026#34;) .toolbar { ToolbarItem(placement: .topBarTrailing) { Button(action: { showSetting.toggle() }, label: { Image(systemName: \u0026#34;gear\u0026#34;) }) } } } } } Add a function to send the data to the server, receive a pass, create the .pkpass file and show it to the user The postAndPreviewPass() method is sending the information to a server and then turning that into a digital pass, like a movie ticket or boarding pass, that you can see in the app. First, it shows a spinner to let you know it\u0026rsquo;s working. Then, it sends off the details and waits for a reply. If all goes well, it saves this info as a special pass file. After that, the app tries to turn this file into a digital pass you can actually use. If there\u0026rsquo;s a problem at any step, the app will show an error message instead. This makes it super easy to get and use passes without leaving the app.\nfunc postAndPreviewPass() { isLoading = true // Replace this URL with your own guard let url = URL(string: \u0026#34;http://\\(serverIP)\u0026#34;) else { print(\u0026#34;Invalid URL\u0026#34;) return } var request = URLRequest(url: url) request.httpMethod = \u0026#34;POST\u0026#34; request.addValue(\u0026#34;application/json\u0026#34;, forHTTPHeaderField: \u0026#34;Content-Type\u0026#34;) let payload: [String: Any] = [ \u0026#34;name\u0026#34;: formData.fullName, \u0026#34;cardNr\u0026#34;: formData.cardNr, \u0026#34;dateFrom\u0026#34;: formData.dateFrom, \u0026#34;dateTo\u0026#34;: formData.dateTo, \u0026#34;dateBirth\u0026#34;: formData.dateBirth, \u0026#34;aztecCode\u0026#34;: formData.aztecCode, \u0026#34;type\u0026#34;: formData.type, \u0026#34;image\u0026#34; : formData.imgBase64 ] do { request.httpBody = try JSONSerialization.data(withJSONObject: payload, options: []) let task = URLSession.shared.dataTask(with: request) { (data, _, error) in defer { self.isLoading = false } guard let data = data, error == nil else { print(\u0026#34;Request failed: \\(error?.localizedDescription ?? \u0026#34;No data\u0026#34;)\u0026#34;) return } print(\u0026#34;Received data from server: \\(data)\u0026#34;) if let dir = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask).first { let fileURL = dir.appendingPathComponent(\u0026#34;file.pkpass\u0026#34;) do { try data.write(to: fileURL, options: .atomic) print(\u0026#34;pkpass file saved\u0026#34;) let passData = try Data(contentsOf: fileURL) print(\u0026#34;Read \\(passData.count) bytes from saved file\u0026#34;) do { let pass = try PKPass(data: passData) print(\u0026#34;Created PKPass object\u0026#34;) DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) { self.pass = pass self.showPassView = true } } catch { print(\u0026#34;Error creating PKPass object: \\(error)\u0026#34;) DispatchQueue.main.async { self.errorText = \u0026#34;Error creating PKPass object: \\(error)\u0026#34; self.showError = true } } } catch { print(\u0026#34;An error occurred: \\(error)\u0026#34;) DispatchQueue.main.async { self.errorText = \u0026#34;An error occurred: \\(error)\u0026#34; self.showError = true } } } } task.resume() } catch { print(\u0026#34;Failed to serialize JSON: \\(error)\u0026#34;) DispatchQueue.main.async { self.errorText = \u0026#34;Failed to serialize JSON: \\(error)\u0026#34; self.showError = true } } } We also need extensions to UIImage to scale and crop the image extension UIImage { /// Scales the image to a maximum dimension (width or height). func scaledDown(to maxDimension: CGFloat) -\u0026gt; UIImage { let aspectRatio: CGFloat = min(maxDimension / size.width, maxDimension / size.height) let newSize = CGSize(width: size.width * aspectRatio, height: size.height * aspectRatio) let renderer = UIGraphicsImageRenderer(size: newSize) return renderer.image { context in self.draw(in: CGRect(origin: .zero, size: newSize)) } } func cropping(to rect: CGRect) -\u0026gt; UIImage? { guard let cgImage = self.cgImage?.cropping(to: rect) else { return nil } return UIImage(cgImage: cgImage, scale: self.scale, orientation: self.imageOrientation) } } The AddPassView struct is the final step in Swift that presents a view for users to add a digital pass to their Apple Wallet using the PKAddPassesViewController from the PassKit framework. import Foundation import PassKit import SwiftUI import UIKit struct AddPassView: UIViewControllerRepresentable { typealias UIViewControllerType = PKAddPassesViewController @Environment (\\.presentationMode) var presentationMode @Binding var pass: PKPass? func makeUIViewController(context: Context) -\u0026gt; PKAddPassesViewController { let passVC = PKAddPassesViewController(pass: self.pass!) return passVC! } func updateUIViewController(_ uiViewController: PKAddPassesViewController, context: Context) { // Nothing goes here } } ","permalink":"http://localhost:1313/posts/walletpass/","summary":"Welcome to my step-by-step guide on how to build your own digital ticket for the Apple Wallet. Today, I\u0026rsquo;m going to show you how to set up a backend system and create an app with SwiftUI that lets you store and use tickets right on your iPhone.\nWe’re going to turn the Klimaticket, a yearly public transport ticket in Austria, into a ticket on your phone. This will make your travels simpler and help the planet too.","title":"Wallet Pass - Klimaticket"},{"content":"Creating custom colors in SwiftUI enhances the visual appeal of your app and maintains consistency across the user interface. Extending the Color struct in SwiftUI is an efficient way to define and manage custom colors. Follow this step-by-step guide to learn how:\nOrganize Your Code: Begin by creating a new Swift file. Naming it CustomColors.swift would be a logical choice. This practice helps in keeping your codebase organized and clean.\nExtend the Color Struct: Open your new Swift file, and start by importing the SwiftUI framework. Then, extend the Color struct to add your custom color definitions.\nDefine Custom Colors: Within the extension, define static properties for your custom colors. Each property should return an instance of Color.\nimport SwiftUI extension Color { static let customRed = Color(red: 0.862, green: 0.1176, blue: 0.2078) static let customHexBlue = Color(hex: \u0026#34;#0000FF\u0026#34;) init(hex: String) { let hex = hex.trimmingCharacters(in: CharacterSet.alphanumerics.inverted) var int: UInt64 = 0 Scanner(string: hex).scanHexInt64(\u0026amp;int) let a, r, g, b: UInt64 switch hex.count { case 3: // RGB (12-bit) (a, r, g, b) = (255, (int \u0026gt;\u0026gt; 8) * 17, (int \u0026gt;\u0026gt; 4 \u0026amp; 0xF) * 17, (int \u0026amp; 0xF) * 17) case 6: // RGB (24-bit) (a, r, g, b) = (255, int \u0026gt;\u0026gt; 16, int \u0026gt;\u0026gt; 8 \u0026amp; 0xFF, int \u0026amp; 0xFF) case 8: // ARGB (32-bit) (a, r, g, b) = (int \u0026gt;\u0026gt; 24, int \u0026gt;\u0026gt; 16 \u0026amp; 0xFF, int \u0026gt;\u0026gt; 8 \u0026amp; 0xFF, int \u0026amp; 0xFF) default: (a, r, g, b) = (255, 0, 0, 0) } self.init( .sRGB, red: Double(r) / 255, green: Double(g) / 255, blue: Double(b) / 255, opacity: Double(a) / 255 ) } } In the code above, we\u0026rsquo;ve defined two custom colors and an initializer for hex values:\ncustomRed: A predefined custom red color. customHexBlue: A custom blue color initialized using a hex value. init(hex:): An initializer to create a color from a hex string. Usage in Your SwiftUI Project: You can now use your custom colors as Color.customRed, Color.customHexBlue, and so on, throughout your SwiftUI project. Handling Hex Colors: The Color extension includes an initializer for hex strings, allowing you to easily define colors using hex values. The initializer handles different formats including RGB, ARGB, and more, converting them into a Color object.\n","permalink":"http://localhost:1313/posts/customcolors/","summary":"Creating custom colors in SwiftUI enhances the visual appeal of your app and maintains consistency across the user interface. Extending the Color struct in SwiftUI is an efficient way to define and manage custom colors. Follow this step-by-step guide to learn how:\nOrganize Your Code: Begin by creating a new Swift file. Naming it CustomColors.swift would be a logical choice. This practice helps in keeping your codebase organized and clean.","title":"Custom Colors in SwiftUI"},{"content":"When it comes to aligning views in SwiftUI, Apple has provided a powerful and flexible system. However, sometimes you might find yourself wishing for a simpler way to handle common alignment scenarios. In this article, we’ll explore how to extend the View protocol to include two new methods, hAlign(_:) and vAlign(_:), that make horizontal and vertical alignment more straightforward.\nExtending the View Protocol First, let’s take a look at the Swift code snippet that adds these methods:\nextension View { func hAlign(_ alignment: Alignment) -\u0026gt; some View { self .frame(maxWidth: .infinity, alignment: alignment) } func vAlign(_ alignment: Alignment) -\u0026gt; some View { self .frame(maxHeight: .infinity, alignment: alignment) } } This extension adds two methods to the View protocol. Both methods return a modified view, and both take a single parameter of type Alignment.\nUnderstanding hAlign(_:) The hAlign(_:) method is designed for horizontal alignment. It sets a frame around the view with a maximum width of infinity, which allows the view to stretch and fill the horizontal space of its parent container. The view is then aligned within this frame according to the Alignment value passed as a parameter.\nHere’s a breakdown of the components:\nmaxWidth: .infinity: This command allows the frame to expand horizontally to fill the available space. alignment: alignment: This sets the horizontal alignment of the view within the frame. Grasping vAlign(_:) The vAlign(_:) method works in much the same way, but for vertical alignment. It sets a frame with a maximum height of infinity, allowing the view to expand vertically. The vertical alignment is set according to the provided Alignment value.\nComponents breakdown:\nmaxHeight: .infinity: Allows the frame to expand vertically. alignment: alignment: Sets the vertical alignment. Usage Example Here’s how you might use these methods:\nText(\u0026#34;Hello, World!\u0026#34;) .hAlign(.leading) .vAlign(.top) In this example, a Text view displays “Hello, World!”. The hAlign(_:) method aligns the text to the leading edge of its container, while vAlign(_:) aligns it to the top.\nConclusion These methods provide a succinct way to align views within their parent containers, without the need for more complex layout containers or alignment guides. Whether you’re a seasoned SwiftUI developer or just getting started, these extensions can help streamline your code and make your layout intentions clear.\n","permalink":"http://localhost:1313/posts/halign_valign/","summary":"When it comes to aligning views in SwiftUI, Apple has provided a powerful and flexible system. However, sometimes you might find yourself wishing for a simpler way to handle common alignment scenarios. In this article, we’ll explore how to extend the View protocol to include two new methods, hAlign(_:) and vAlign(_:), that make horizontal and vertical alignment more straightforward.\nExtending the View Protocol First, let’s take a look at the Swift code snippet that adds these methods:","title":"Simplifying View Alignment with `hAlign` and `vAlign`"},{"content":"Welcome to this comprehensive step-by-step tutorial designed to guide you through the process of setting up a backend environment for a passkeys using Docker Desktop. It will also guide you through the process of obtaining an Apple Developer Team-ID, a unique identifier required to manage your team on Apple\u0026rsquo;s Developer platform.\nBy the end of this tutorial, you\u0026rsquo;ll have a fully functional backend setup for your passkey workshop, and you\u0026rsquo;ll be capable of managing and running your applications more effectively.\nHappy learning!\n1. install Docker Desktop https://www.docker.com/products/docker-desktop/\n2. install Git https://git-scm.com/downloads\n3. get Apple Developer Team-ID (Optional) https://developer.apple.com/help/account/manage-your-team/locate-your-team-id/\n4. setup the backend automated / script (macOS and Linux): !! for windows scroll down\nClone the repository git clone https://github.com/YubicoLabs/passkey-workshop Navigate to the deploy folder cd passkey-workshop/deploy run the mobile.sh script ./cloudflared.sh edit .env file open the file nano .env make changes if you have a Team-ID -\u0026gt; add it here if you don\u0026rsquo;t have a Team-ID -\u0026gt; change one character run the mobile.sh script again ./cloudflared.sh copy the url from the shell open the url in a browser (use https://) go to the TestPanel you can now register and sign in with passkeys note: only the TestPanel is working! manual (windows): start Powershell Clone the repository git clone https://github.com/YubicoLabs/passkey-workshop Navigate to the deploy folder cd passkey-workshop/deploy Copy the environment file cp cloudflared.env .env Copy the frontend code cp -r ../examples/clients/web/react/passkey-client/ react-app/source (optional) Edit the apple-app-site-association file with your Apple TeamID. nano react-app/source/public/.well-known/apple-app-site-association { \u0026#34;webcredentials\u0026#34;: { \u0026#34;apps\u0026#34;: [ \u0026#34;UVWXYZ1234.fyi.passkey.pawskeyUVWXYZ1234\u0026#34; ] } } Build the passkey-client docker compose build passkey-client Copy the backend code cp -r ../examples/relyingParties/java-spring/ java-app/source/ Start your tunnel docker compose --profile tunnel up -d Lookup the tunnel URL in cloudflared\u0026rsquo;s output, either in Docker Desktop or using docker compose --profile tunnel logs *example log:* INF +--------------------------------------------------------------------------------------+ INF | Your quick Tunnel has been created! Visit it at (it may take some time to be reachable): | INF | https://your-proxied-tunnel-endpoint.trycloudflare.com | INF +--------------------------------------------------------------------------------------+ Edit your .env file and set the values of RP_ID, RP_ALLOWED_ORIGINS, and RP_ALLOWED_CROSS_ORIGINS to your assigned hostname RP_ID=replace-with-your-hostname.trycloudflare.com RP_ALLOWED_ORIGINS=replace-with-your-hostname.trycloudflare.com RP_ALLOWED_CROSS_ORIGINS=replace-with-your-hostname.trycloudflare.com Also edit the URL for your RP backend API so it includes your tunnel hostname\nREACT_APP_API=https://replace-with-your-hostname.trycloudflare.com/v1 run docker compose --profile mobile up -d open the url in a browser go to the TestPanel you can now register and sign in with passkeys note: only the TestPanel is working! ","permalink":"http://localhost:1313/posts/passkeys/","summary":"Welcome to this comprehensive step-by-step tutorial designed to guide you through the process of setting up a backend environment for a passkeys using Docker Desktop. It will also guide you through the process of obtaining an Apple Developer Team-ID, a unique identifier required to manage your team on Apple\u0026rsquo;s Developer platform.\nBy the end of this tutorial, you\u0026rsquo;ll have a fully functional backend setup for your passkey workshop, and you\u0026rsquo;ll be capable of managing and running your applications more effectively.","title":"Passkeys"},{"content":"Semantic versioning, also known as semver, is a popular versioning scheme used in software development to manage the releases of a project and communicate changes between different versions to stakeholders. Semantic versioning provides a standard way of versioning software, which makes it easier for developers to understand the compatibility of different versions and avoid potential breaking changes. In this article, we will explain the key concepts of semantic versioning and provide some examples to help you get started.\nThe Basics of Semantic Versioning Semantic versioning consists of three components: Major version, minor version, and patch version, separated by dots. The version number is written in the format X.Y.Z, where X is the major version, Y is the minor version, and Z is the patch version.\nEach component has a specific meaning and represents different levels of change in the software.\nMajor version (X): This component represents a significant change in the software, such as adding new features, changing the API, or making breaking changes. A change in the major version means that older versions are no longer compatible with the latest version. Minor version (Y): This component represents a new feature or improvement to the software, without breaking existing functionality. When a new feature is added or a change is made that is backward-compatible, the minor version is incremented. Patch version (Z): This component represents a bug fix or a small change in the software that does not affect the functionality of the software. When a bug is fixed or a small change is made, the patch version is incremented. Examples of Semantic Versioning Here are some examples to help you understand how semantic versioning works in practice.\n1. Initial release of a project When you are starting a new project, you can start with version 1.0.0. This version number represents the initial release of your project and includes the first set of features and functionality.\n2. Adding a new feature When you add a new feature to your project, you can increment the minor version, for example, from 1.0.0 to 1.1.0. The new feature is backward-compatible with the previous version and does not break existing functionality.\n3. Fixing a bug When you fix a bug in your project, you can increment the patch version, for example, from 1.1.0 to 1.1.1. The bug fix is backward-compatible with the previous version and does not affect existing functionality.\n4. Making a breaking change When you make a change to your project that breaks existing functionality, you can increment the major version, for example, from 1.1.1 to 2.0.0. The breaking change may affect other parts of the software that depend on the changed functionality, so it is important to communicate the change to stakeholders.\nConclusion Semantic versioning is a simple yet powerful tool for managing the releases of a software project. It provides a clear and standard way of versioning software that makes it easier for developers to understand the compatibility of different versions and avoid potential breaking changes. By following semantic versioning, you can ensure that your project remains backward-compatible and that stakeholders are informed of any breaking changes.\n","permalink":"http://localhost:1313/posts/semanticversioning/","summary":"Semantic versioning, also known as semver, is a popular versioning scheme used in software development to manage the releases of a project and communicate changes between different versions to stakeholders. Semantic versioning provides a standard way of versioning software, which makes it easier for developers to understand the compatibility of different versions and avoid potential breaking changes. In this article, we will explain the key concepts of semantic versioning and provide some examples to help you get started.","title":"Semantic Versioning: an Introduction with Examples"},{"content":"Introduction Welcome to my blog post on Font Awesome 6 in Xcode \u0026amp; SwiftUI.\nIn this post, I\u0026rsquo;ll be sharing with you the steps on how to install Font Awesome icons in your Xcode project using SwiftUI.\nWe\u0026rsquo;ll start by downloading the font files, adding the .otf files to the project, adding the fonts to the Info.plist file and creating a new struct for CustomFonts.\nThen, I\u0026rsquo;ll show you how to use Font Awesome icons in your Xcode project. I\u0026rsquo;ll take you through the process of searching for an icon on Font Awesome, copying the glyph, and adding the icon as text.\nTo wrap things up, I\u0026rsquo;ll also include a style preview to give you an idea of the various font styles available. Whether you\u0026rsquo;re a beginner or an experienced iOS developer, this post will guide you through the process of adding Font Awesome icons to your Xcode project with ease.\nHow to add\u0026hellip; 1. download the font files Download Font Awesome\n→ use the „For The Desktop“ Version\n2. add .otf files to the project You will then be prompted with a dialog box.\nWarning\nBe sure to check your project name under “Add to targets.” This will ensure that your fonts are compiled as assets at build time.\n3. add the fonts to „Info.plist“ file \u0026lt;key\u0026gt;UIAppFonts\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Brands-Regular-400.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Duotone-Solid-900.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Pro-Light-300.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Pro-Regular-400.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Pro-Solid-900.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Pro-Thin-100.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Sharp-Light-300.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Sharp-Regular-400.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Sharp-Solid-900.otf\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;Font Awesome 6 Sharp-Thin-100.otf\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;/dict\u0026gt; Note\nThe fonts might not be named like these anymore.\nCheck real filenames!\n4. create a new struct for CustomFonts create a new Swift File (name: \u0026ldquo;CustomFonts) add this code extension View { func faPro(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Pro-Regular\u0026#34;, size: size)) } func faProLight(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Pro-Light\u0026#34;, size: size)) } func faProSolid(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Pro-Solid\u0026#34;, size: size)) } func faProThin(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Pro-Thin\u0026#34;, size: size)) } func faDuotone(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Duotone-Solid\u0026#34;, size: size)) } func faSharp(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Sharp-Regular\u0026#34;, size: size)) } func faSharpLight(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Sharp-Light\u0026#34;, size: size)) } func faSharpSolid(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Sharp-Solid\u0026#34;, size: size)) } func faBrands(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Brands-Regular\u0026#34;, size: size)) } func faSharpThin(size: CGFloat) -\u0026gt; some View { self.font(.custom(\u0026#34;FontAwesome6Sharp-Thin\u0026#34;, size: size)) } } How to use\u0026hellip; 1. go to Font Awesome and search for an icon Search | Font Awesome\n2. click Copy Glyph 3. add the icon as text Text(\u0026#34;\u0026lt;icon\u0026gt;\u0026#34;) .faProSolid(size: 20) Text(\u0026#34;\u0026lt;icon\u0026gt;\u0026#34;) .faDuotone(size: 20) Text(\u0026#34;\u0026lt;icon\u0026gt;\u0026#34;) .faSharpThin(size: 20) Style preview ","permalink":"http://localhost:1313/posts/fontawesome/","summary":"Introduction Welcome to my blog post on Font Awesome 6 in Xcode \u0026amp; SwiftUI.\nIn this post, I\u0026rsquo;ll be sharing with you the steps on how to install Font Awesome icons in your Xcode project using SwiftUI.\nWe\u0026rsquo;ll start by downloading the font files, adding the .otf files to the project, adding the fonts to the Info.plist file and creating a new struct for CustomFonts.\nThen, I\u0026rsquo;ll show you how to use Font Awesome icons in your Xcode project.","title":"Font Awesome 6 in xCode \u0026 SwiftUI"},{"content":"Introduction Welcome to my blog post on Universal Links in SwiftUI!\nUniversal links are a powerful feature that allows you to link directly to your app from an external source, such as a website. This means that you can take your users directly to specific content within your app, without having to go through the app store or the website. In this post, I will walk you through the process of setting up Universal Links in a SwiftUI app.\nFirst, we will look at how to find your Team ID and Bundle ID. You\u0026rsquo;ll need these values to configure the association file and the app entitlements.\nNext, we\u0026rsquo;ll create the association file and upload it to your website. This file contains information about the links that should be associated with your app, and it is a key part of the setup process.\nWe\u0026rsquo;ll then add the Associated Domains capability to your app, and add the appropriate domain entries to your entitlements. This is an important step that allows your app to receive the universal links and handle them appropriately.\nIn the code logic section, I\u0026rsquo;ll show you how to add code to your SwiftUI app that will handle the universal links when they are received. This is done using the onOpenURL method, which is called whenever your app is opened using a universal link.\nFinally, I\u0026rsquo;ll show you how to enable the Universal Links testing-feature on an iPhone and how to verify that the links are set up correctly.\nBy the end of this post, you will have a complete understanding of how Universal Links work in SwiftUI and will be able to set them up in your own apps. Let\u0026rsquo;s get started!\nHow to 1. get Team-ID and Bundle-ID Team ID: go to https://developer.apple.com/account scroll to Membership details and find the Team ID Bundle ID: open the Xcode project click on the project name (left panel) click Signing \u0026amp; Capabilities find the Bundle ID 2. create the association file create a file with the name: apple-app-site-association (without extension!) this is an example of the file. also check: supporting associated domains { \u0026#34;applinks\u0026#34;: { \u0026#34;details\u0026#34;: [ { \u0026#34;appIDs\u0026#34;: [\u0026#34;\u0026lt;Team-ID\u0026gt;.\u0026lt;Bundle-ID\u0026gt;\u0026#34;], \u0026#34;components\u0026#34;: [ { \u0026#34;/\u0026#34;: \u0026#34;/app/?*\u0026#34;, } ] } ] } } 3. upload it upload this file to: https://\u0026lt;fully qualified domain\u0026gt;/.well-known/apple-app-site-association 4. add entitlement to your app add the capability Associated Domains add applinks:\u0026lt;fully qualified domain\u0026gt;?mode=developer for the development-mode or applinks:\u0026lt;fully qualified domain\u0026gt; for productive mode 5. add code-logic to the app This allows to register a handler that will be called whenever your application is opened using a universal link, regardless of its state (foreground, background, force-quit).\n@main struct ContentView: App { var body: some Scene { WindowGroup { VStack { Text(\u0026#34;Hello world\u0026#34;) } .onOpenURL { url in // handle universal links print(\u0026#34;url: \\(url)\u0026#34;) } } } } 6. enable on iPhone go to Settings go to Developer enable Associated Domains Development reboot your phone 7. install App Info\nIf the app is already on your phone:\ndelete the app re-install the app 8. check the association go to Settings go to Developer tap Diagnostics enter the URL I\u0026rsquo;m using /app/test because I added this in my file for the server: \u0026quot;/\u0026quot;: \u0026quot;/app/?*\u0026quot; see if it worked 9. test if you try to open an URL in Safari (like specified above)\ne.g. https://\u0026lt;fully qualified domain\u0026gt;/app/something a banner should appear: if you save the URL somewhere (e.g. the notes app) and tap it afterwards, the app should open. 10. troubleshooting start the Console app on your Mac select your device and click start streaming set the search to swcd These logs provide some activities related to Universal Links and other associated domain features. We can see the system is downloading the AASA file or not if it errors it will display here.\n","permalink":"http://localhost:1313/posts/universallinks/","summary":"Introduction Welcome to my blog post on Universal Links in SwiftUI!\nUniversal links are a powerful feature that allows you to link directly to your app from an external source, such as a website. This means that you can take your users directly to specific content within your app, without having to go through the app store or the website. In this post, I will walk you through the process of setting up Universal Links in a SwiftUI app.","title":"Universal Links in SwiftUI"},{"content":" Full Name: Michael Luegmayer some facts: 27 years old from Austria 🇦🇹 Academic Background Bachelor\u0026rsquo;s Degree in Mobile Computing - University of Applied Sciences Upper Austria, Campus Hagenberg Professional Experience Internship at AhoiKapptn! App Development for Samariterbund Österreich - Gruppe Lin ","permalink":"http://localhost:1313/me/","summary":"about me","title":"Hi there, I’m Michael 👋"},{"content":"MantaLog Project Overview: MantaLog represents my journey into iOS app development, intertwining my passion for diving with my enthusiasm for tech. It\u0026rsquo;s more than just a dive log - it\u0026rsquo;s an experience tailored for the modern diver.\nTechnical Highlights: Platform \u0026amp; Tools: Developed for iOS using Swift and SwiftUI. Data Management: Leveraged CoreData / SwiftData for efficient data storage and retrieval. Synchronization: Integrated iCloud Sync, not only ensuring seamless data synchronization across all iOS devices but also providing a secure backup for your precious dive logs. Key Features: Bluetooth LE Integration: Effortless syncing with dive computers for accurate logging.\nEmergency Functions: Added safety layers for those unpredictable dive situations.\nDive Insights \u0026amp; Stats: Dive patterns, depths, and location statistics for a comprehensive dive review.\nLicense Storage: A digital wallet for divers to store and showcase their diving certificates.\nCreating MantaLog is an ongoing enriching experience, merging the thrill of diving with my deep passion for app development.\nMy Ticket Wallet App - KlimaWallet What I Made: I wanted to add my KlimaTicket, a year-long pass for Austria\u0026rsquo;s public transport, to my iPhone\u0026rsquo;s Apple Wallet for convenience. Since no solution existed, I developed my own app that converts the physical KlimaTicket into a digital Wallet Pass.\nHow I Made It: Tools I Used: I used Node.js to make the backend. For the app part that you see on the iPhone, I used Swift and SwiftUI. How It Works with Data: When you use the app, it lets you scan the Aztec code on your physical KlimaTicket using a feature called CodeScanner. After scanning, you can add more infos like your name and the expiry date. Then the app creates a .pkpass file — that\u0026rsquo;s a special kind of file for Apple Wallet. You can see a preview of this pass right in the app, and with just a tap, you can add it to your Apple Wallet. What the App Does: Turns Your Ticket Digital: You can change your paper KlimaTicket into a digital one that goes right into your Apple Wallet.\nQuick to Get: You get your digital ticket fast and put it into your Apple Wallet in no time.\nMaking this app was all about making something really useful and getting better at building apps and backends. It\u0026rsquo;s cool to see how a little idea to fix a problem for myself can turn into something big that others might use too.\nFor more infos look at my blog post\u0026hellip; Wallet Pass - Klimaticket\nVINOTES Project Overview: Vinotes encapsulates the essence of wine tasting in a digitized form, born from a university project. Crafted by a team of four dedicated individuals, we split our expertise to breathe life into both iOS and Android platforms. By infusing our love for wine with the modernity of tech, Vinotes offers wine enthusiasts a virtual tasting experience like no other.\nTechnical Highlights: Platform \u0026amp; Tools: Crafted for both iOS and Android - the iOS version was developed using Swift and SwiftUI, while the Android counterpart utilized its native tools.\nData Management: Firebase was our go-to choice, ensuring robust and real-time data storage, retrieval, and user authentication.\nNative Features: Seamless integration of native functions, including drawers, \u0026lsquo;Sign in with Apple/Google\u0026rsquo;, and location services, was a cornerstone of our project, giving users an intuitive experience.\nKey Features: Discover Wineries: Explore new wineries, curating an ever-growing list of places to experience.\nPersonalized Tasting Notes: As you taste each wine, add your impressions and tasting notes for future reference.\nFavorites: Keep your cherished wines and wineries in one place by adding them to your favorites.\nShop \u0026amp; Reorder: With an integrated cart system, ordering wines is just a tap away. Can’t remember how you felt about a particular wine? Simply revisit your notes and reorder with confidence.\nIt\u0026rsquo;s a journey into the world of wines, making every sip and note count. As creators, we took pride in bridging the gap between traditional wine tasting and the digital realm.\nPrototype Space Runner - Unreal Engine 5 ","permalink":"http://localhost:1313/myapps/","summary":"my apps","title":"My Apps"}]